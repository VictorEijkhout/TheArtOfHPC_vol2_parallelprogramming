% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Parallel Programming in MPI and OpenMP'
%%%% by Victor Eijkhout, copyright 2012-2022
%%%%
%%%% mpi-elementary.tex : elementary datatypes
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Level 0 {Elementary data types}
\label{sec:elementary}
\index{datatype!elementary|(}

MPI has a number of elementary data types, corresponding to the 
simple data types of the host languages.
The names are made to resemble the types of C and~Fortran, 
for instance \indexmpishow{MPI_FLOAT} and \indexmpishow{MPI_DOUBLE}
corresponding to \lstinline{float} and \lstinline{double} in~C,
versus
\indexmpishow{MPI_REAL} and \indexmpishow{MPI_DOUBLE_PRECISION}
corresponding to \finline{Real} and \finline{Double precision}
in~Fortran.

\begin{comment}
  MPI calls accept arrays of elements:
  \begin{lstlisting}
    double x[20];
    MPI_Send( x,20,MPI_DOUBLE, ..... )
  \end{lstlisting}
  so for a single element you need to take its address:
  \begin{lstlisting}
    double x;
    MPI_Send( &x,1,MPI_DOUBLE, ..... )
  \end{lstlisting}
\end{comment}

\Level 1 {C/C++}
\index{datatype!elementary!in C}

Here we illustrate the correspondence between a type used to declare a variable,
and how this type appears in MPI communication routines:
\begin{lstlisting}
long int i;
MPI_Send(&i,1,MPI_LONG,target,tag,comm);
\end{lstlisting}

\begin{table}[ht]
\begin{tabular}{|ll|}
  \hline
  C type&MPI type\\
  \hline
% char
\lstinline+char+&\indexmpidef{MPI_CHAR}\\
\lstinline+unsigned char+&\indexmpidef{MPI_UNSIGNED_CHAR}\\
\lstinline+char+&\indexmpidef{MPI_SIGNED_CHAR}\\
% int
\lstinline+short+&\indexmpidef{MPI_SHORT}\\
\lstinline+unsigned short+&\indexmpidef{MPI_UNSIGNED_SHORT}\\
\lstinline+int+&\indexmpidef{MPI_INT}\\
\lstinline+unsigned int+&\indexmpidef{MPI_UNSIGNED}\\
\lstinline+long int+&\indexmpidef{MPI_LONG}\\
\lstinline+unsigned long int+&\indexmpidef{MPI_UNSIGNED_LONG}\\
\lstinline+long long int+&\indexmpidef{MPI_LONG_LONG_INT}\\
% real
\lstinline+float+&\indexmpidef{MPI_FLOAT}\\
\lstinline+double+&\indexmpidef{MPI_DOUBLE}\\
\lstinline+long double+&\indexmpidef{MPI_LONG_DOUBLE}\\
% other
\lstinline+unsigned char+&\indexmpidef{MPI_BYTE}\\
(does not correspond to a C type)&\indexmpishow{MPI_PACKED}\\
  \hline
\end{tabular}
\caption{Elementary datatypes in C}
\label{tab:elemen-c}
\end{table}

\begin{table}[ht]
  \begin{tabular}{ll}
    \toprule
    \lstinline+_Bool+&\indexmpidef{MPI_C_BOOL}\\
    \lstinline+float _Complex+&\indexmpidef{MPI_C_COMPLEX}\\
                              &\indexmpidef{MPI_C_FLOAT_COMPLEX}\\
    \lstinline+double _Complex+&\indexmpidef{MPI_C_DOUBLE_COMPLEX}\\
    \lstinline+long double _Complex+&\indexmpidef{MPI_C_LONG_DOUBLE_COMPLEX}\\
    \bottomrule
  \end{tabular}
  \caption{C99 synonym types.}
  \label{tab:c99-types}  
\end{table}

\begin{table}[ht]
  \begin{tabular}{ll}
    \toprule
    \lstinline+int8_t+&\indexmpidef{MPI_INT8_T}\\
    \lstinline+int16_t+&\indexmpidef{MPI_INT16_T}\\
    \lstinline+int32_t+&\indexmpidef{MPI_INT32_T}\\
    \lstinline+int64_t+&\indexmpidef{MPI_INT64_T}\\
    \midrule
    \lstinline+uint8_t+&\indexmpidef{MPI_UINT8_T}\\
    \lstinline+uint16_t+&\indexmpidef{MPI_UINT16_T}\\
    \lstinline+uint32_t+&\indexmpidef{MPI_UINT32_T}\\
    \lstinline+uint64_t+&\indexmpidef{MPI_UINT64_T}\\
    \bottomrule
  \end{tabular}
  \caption{C11 fixed width integer types.}
  \label{tab:c11-int-types}
\end{table}

\begin{itemize}
\item
  There is some, but not complete, support for \cstandard{99} types.
\item
  The \indexmpishow{MPI_LONG_INT} type is not an integer type,
  but rather a \lstinline{long} and an \lstinline{int} packed together;
  see section~\ref{sec:minmaxloc}.
\item 
  See section~\ref{sec:mpi-byte-type} for \indexmpishow{MPI_Aint}
  and more about byte counting.
\end{itemize}

\Level 1 {Fortran}
\index{datatype!elementary!in Fortran}
\lstset{style=reviewcode,language=Fortran} %pyskip

\begin{table}[ht]
\hbox{
\begin{tabular}{|ll|}
  \hline
\indexmpidef{MPI_CHARACTER}&Character(Len=1)\\
% int
\indexmpidef{MPI_INTEGER}&\\
% real
\indexmpidef{MPI_REAL}&\\
\indexmpidef{MPI_DOUBLE_PRECISION}&\\
% complex
\indexmpidef{MPI_COMPLEX}&\\
% other
\indexmpidef{MPI_LOGICAL}&\\
\indexmpishow{MPI_BYTE}&\\
\indexmpidef{MPI_PACKED}&\\
  \hline
\end{tabular}

\begin{tabular}{|l|}
  \hline
% int
\indexmpidef{MPI_INTEGER1}\\
\indexmpidef{MPI_INTEGER2}\\
\indexmpidef{MPI_INTEGER4}\\
\indexmpidef{MPI_INTEGER8}\\
\indexmpidef{MPI_INTEGER16}\\
% real
\indexmpidef{MPI_REAL2}\\
\indexmpidef{MPI_REAL4}\\
\indexmpidef{MPI_REAL8}\\
% complex
\indexmpidef{MPI_DOUBLE_COMPLEX}\\ \kern20pt Complex(Kind=Kind(0.d0))\\
  \hline
\end{tabular}
}
\caption{Standard Fortran types (left) and common extension (right)}
\label{tab:mpi-f-types}
\end{table}

Not all these types need be supported, for instance
\indexmpishow{MPI_INTEGER16} may not exist, in which case it will be
equivalent to \indexmpishow{MPI_DATATYPE_NULL}.

The default integer type \indexmpishow{MPI_INTEGER} is equivalent to
\lstinline{INTEGER(KIND=MPI_INTEGER_KIND)}.

\Level 2 {Big data types}

The C type \indexmpishow{MPI_Count} corresponds to an integer of type
\indexmpidef{MPI_COUNT_KIND}, used most prominently in `big data'
routines such as \indexmpishow{MPI_Type_size_x} 
(section~\ref{sec:mpi-type-size}):
\begin{lstlisting}
Integer(kind=MPI_COUNT_KIND) :: count
call MPI_Type_size_x(my_type, count)
\end{lstlisting}

\begin{mpifournote}{Count type}
  For every routine \lstinline{MPI_Something}
  with an \lstinline{int} count parameter,
  there is a corresponding routine \lstinline{MPI_Something_c}
  with an \lstinline{MPI_Count} parameter.

  The above \lstinline{MPI_Something_x} routines
  will probably be deprecated in the \mpistandard{4.1} standard.
\end{mpifournote}

\Level 2 {Byte counting types}
\label{sec:mpi-byte-count}

Kind \indexmpishow{MPI_ADDRESS_KIND} is used for \indexmpishow{MPI_Aint}
quantities, used in \ac{RMA} windows; see section~\ref{sec:mpi-put}.

The \indexmpidef{MPI_OFFSET_KIND}
is used to define \indexmpishow{MPI_Offset} quantities,
used in file I/O; section~\ref{sec:mpi-filepoint}.

\Level 2 {Fortran90 kind-defined types}
\label{sec:f90-types}

If your \fstandard{90} code uses \lstinline{KIND} to define scalar types with
specified precision, these do not in general correspond to any
predefined MPI datatypes. Hence the following routines exist to make
\emph{MPI equivalences of Fortran scalar types}%
\index{Fortran!MPI equivalences of scalar types}:
\begin{itemize}
\item
  \indexmpiref{MPI_Type_create_f90_integer}
\item
  \indexmpiref{MPI_Type_create_f90_real}
\item
  \indexmpiref{MPI_Type_create_f90_complex}.
\end{itemize}

Examples:
\begin{lstlisting}
INTEGER ( KIND = SELECTED_INT_KIND(15) ) , &
 DIMENSION(100) :: array INTEGER :: root , integertype , error 

CALL MPI_Type_create_f90_integer( 15 , integertype , error )
CALL MPI_Bcast ( array , 100 , &
 integertype , root , MPI_COMM_WORLD , error )

REAL ( KIND = SELECTED_REAL_KIND(15 ,300) ) , &
 DIMENSION(100) :: array
CALL MPI_Type_create_f90_real( 15 , 300 , realtype , error )

COMPLEX ( KIND = SELECTED_REAL_KIND(15 ,300) ) , &
 DIMENSION(100) :: array 
CALL MPI_Type_create_f90_complex( 15 , 300 , complextype , error )
\end{lstlisting}
\lstset{style=reviewcode,language=C} %pyskip

\Level 1 {Python}
\index{datatype!elementary!in Python}

In python, all buffer data comes from \indexterm{Numpy}.

\begin{tabular}{|ll|}
  \hline
  mpi4py type&NumPy type\\
  \hline
  \n{MPI.INT}&\n{np.intc}\\
             &\n{np.int32}\\
  \n{MPI.LONG}&\n{np.int64}\\
  \n{MPI.FLOAT}&\n{np.float32}\\
  \n{MPI.DOUBLE}&\n{np.float64}\\
  \hline
\end{tabular}

In this table we see that
Numpy has three integer types,
one corresponding to C~\lstinline{int}s,
and two with the number of bits explicitly indicated.
There used to be a \lstinline{np.int} type,
but this is deprecated as of \indextermbus{Numpy}{1.20}

Examples:

\pverbatimsnippet[examples/mpi/p/inttype.py]{npintc}

\pverbatimsnippet{bufallocp}

\Level 2 {Type correspondences MPI / Python}

Above we saw that the number of bytes of a Numpy type can be deduced from
\lstset{language=Python}
\begin{lstlisting}
sizeofint = np.dtype('intc').itemsize  
\end{lstlisting}

It is possible to derive the Numpy type corresponding to an MPI type:
\pverbatimsnippet{mpityp2numpy}

\lstset{language=C}

\Level 1 {Byte addressing types}
\label{sec:mpi-byte-type}

So far we have mostly been taking about datatypes in the context of
sending them. The \indexmpidef{MPI_Aint} type is not so much for
sending, as it is for describing the size of objects, such as the size
of an \indexmpishow{MPI_Win} object (section~\ref{sec:windows})
or byte displacements in \indexmpishow{MPI_Type_create_hindexed}.

Addresses have type \indexmpishow{MPI_Aint}. The start of the address range is
given in \indexmpishow{MPI_BOTTOM}.
See also the \indexmpishow{MPI_Sizeof}
(section~\ref{sec:mpi-type-match})
and
\indexmpishow{MPI_Get_address} routines.

Variables of type \indexmpishow{MPI_Aint} can be sent as \indexmpidef{MPI_AINT}:
\begin{lstlisting}
MPI_Aint address;
MPI_Send( address,1,MPI_AINT, ... );
\end{lstlisting}
See section~\ref{sec:win-dynamic} for an example.

In order to prevent overflow errors in byte calculations
there are support routines \indexmpidef{MPI_Aint_add}
\begin{lstlisting}
MPI_Aint MPI_Aint_add(MPI_Aint base, MPI_Aint disp)
\end{lstlisting}
and similarly \indexmpidef{MPI_Aint_diff}.

\Level 2 {Fortran}

The equivalent of
%\indexmpishowsub{MPI_Aint}{in Fortran}
\indexmpishowf{MPI_Aint} in Fortran
is an integer of kind \indexmpidef{MPI_ADDRESS_KIND}:
\lstset{style=reviewcode,language=Fortran} %pyskip
\begin{lstlisting}
integer(kind=MPI_ADDRESS_KIND) :: winsize
\end{lstlisting}
\lstset{style=reviewcode,language=C} %pyskip

Using this integer kind to compute the size of a window
also requires being able to query the size of the datatype
in that window.
See section~\ref{sec:mpi-type-match} for details.

Example usage in \indexmpishow{MPI_Win_create}:
\lstset{language=Fortran} %pyskip
\begin{lstlisting}
call MPI_Sizeof(windowdata,window_element_size,ierr)
window_size = window_element_size*500
call MPI_Win_create( windowdata,window_size,window_element_size,... )
\end{lstlisting}
\lstset{language=C} %pyskip

\Level 2 {Python}

Here is a good way for finding the size of \indexterm{numpy} datatypes
in bytes:
\pverbatimsnippet{windispp}% source is in one-sided chapter

\Level 1 {Matching language type to MPI type}
\label{sec:mpi-type-match}

In some circumstances you may want to find the MPI type
that corresponds to a type in your programming language.
\begin{itemize}
\item In C++ functions and classes can be templated,
  meaning that the type is not fully known:
\begin{lstlisting}
template<typename T> {
class something<T> {
public:
  void dosend(T input) {
    MPI_Send( &input,1,/* ????? */ );
  };
};
\end{lstlisting}
(Note that in \ac{MPL} this is hardly ever needed
because MPI calls are templated there.)
\item Petsc installations use a generic identifier \indexpetscshow{PetscScalar}
  (or \indexpetscshow{PetscReal})
  with a configuration-dependent realization.
\item The size of a datatype is not always statically known, for instance if
the Fortran \indextermtt{KIND} keyword is used.
\end{itemize}

Here are some MPI mechanisms that address this problem.

\Level 2 {Type matching in C}
\label{sec:mpi-type-match-c}

Datatypes in~C can be translated to MPI types with
%
\indexmpiref{MPI_Type_match_size}
%
where the \lstinline{typeclass} argument is one of
\indexmpishow{MPI_TYPECLASS_REAL},
\indexmpishow{MPI_TYPECLASS_INTEGER},
\indexmpishow{MPI_TYPECLASS_COMPLEX}.

\cverbatimsnippet[examples/mpi/c/typematch.c]{typematchc}

The space that MPI takes for a structure type can be queried in a
variety of ways. First of all \indexmpiref{MPI_Type_size} counts the
\emph{datatype size}\index{MPI!datatype!size} as the 
number of bytes occupied by the data in a type. That means that in an
\emph{MPI vector datatype}\index{MPI!datatype!vector} it does not
count the gaps.
%
\cverbatimsnippet[examples/mpi/c/typesize.c]{vectortypesize}

\begin{comment}
In C, the \indexmpidef{MPI_Datatype} type is defined through the pre-processor,
allowing you to write:
\cverbatimsnippet{datatypevar}
\end{comment}

\Level 2 {Type matching in Fortran}
\label{sec:mpi-type-match-f}

In Fortran, the size of the datatype in the language can be obtained with
\indexmpidef{MPI_Sizeof} (note the nonoptional error parameter!).
This routine is deprecated in \mpistandard{4}: use of
\indextermtt{storage_size} and/or \indextermtt{c_sizeof} is recommended.

\fverbatimsnippet[examples/mpi/c/typematch.c]{typematchf}

Petsc has its own translation mechanism; see section~\ref{sec:petsc-scalar}.

\index{datatype!elementary|)}

